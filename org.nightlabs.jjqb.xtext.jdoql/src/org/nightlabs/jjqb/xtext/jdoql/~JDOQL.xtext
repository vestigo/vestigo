grammar org.nightlabs.jjqb.xtext.jdoql.JDOQL with org.eclipse.xtext.common.Terminals

generate jDOQL "http://www.nightlabs.org/jjqb/xtext/jdoql/JDOQL"

// http://db.apache.org/jdo/specifications.html
// Current spec: 3.0, chapter 26 JDOQL BNF, page 341ff

SingleStringJDOQL:
	selectClause=SelectClause fromClause=FromClause (where=Where)?
;

SelectClause:
	'SELECT' (isUnique?='UNIQUE')? (resultClause=ResultClause)? (intoClause=IntoClause)?
;

ResultClause:
	(isDistinct?='DISTINCT')? resultSpecs+=ResultSpec (',' resultSpecs+=ResultSpec)*
;

IntoClause:
	'INTO' resultClassName=ClassOrInterfaceName
;

FromClause:
	'FROM' candidateClassName=CandidateClassName (excludeClause=ExcludeClause)?
;

Where:
	'WHERE' whereEntry=OrExpression
;

ExcludeClause:
	excludeSubclasses='EXCLUDE SUBCLASSES'
;

QualifiedIdentifier:
	ID ('.'ID)*
;

CandidateClassName:
	QualifiedIdentifier
;

ClassOrInterfaceName:
	QualifiedIdentifier
;

//ResultSpecs:
//	ResultSpec (',')?
//;

ResultSpec:
	primaries+=Primary (resultNaming+=ResultNaming)? (',' primaries+=Primary (resultNaming+=ResultNaming))*
;

ResultNaming:
	'AS' identifier=ID
;

OrExpression returns Expression:
	AndExpression ({OrExpression.entries+=current}  ("||" entries+=AndExpression)+)?
;
 
AndExpression returns Expression:
	ConcreteExpression ({AndExpression.entries+=current} ("&&" entries+=ConcreteExpression)+)?
;

ConcreteExpression returns Expression:
	ParExpression | 
	BinaryOpExpression
//	ExistsExpression |
//	AllExpression |
//	AnyExpression |
//	SomeExpression |
//	CollectionExpression |
//	NullComparisonExpression |
//	EmptyComparisonExpression |
//	LikeExpression |
//	InExpression |
//	BetweenExpression
;

ParExpression returns Expression:
	"(" ExpressionTerm ")"
;

BinaryOpExpression:
	lhs=Variable operator=BinaryOpExpression rhs=ExpressionTerm 
;

Variable:
	Primary |
//	AliasAttributeExpression | 
	ParameterExpression |
	Value
;

ExpressionTerm:
	Variable
//	|
//	QueryExpression
;

ParameterExpression:
	':'name=ID
;

Value:
	IntegerLiteral |
	StringLiteral |
	NullLiteral |
	BooleanLiteral
;

//BooleanExpression returns Expression:
//	left=Expression (op=BooleanOp right=Expression)
//;

//BooleanOp:
//	'>' | '>=' | '<' | '<=' | 'instanceof' | '==' | '!=' | '&&' | '||'
//;
BinaryOp:
	'>' | '>=' | '<' | '<=' | 'instanceof' | '==' | '!='
;



//Expression:
//	left=UnaryExpression (op=InfixOp right=UnaryExpression)?
//;

InfixOp:
	'*' | '/' | '%' | '+' | '-' | '&' | '|'
;

//UnaryExpression:
//	modifier=PrefixOp expression=Primary |
//	cast=Cast expression=Primary |
//	expression=Primary
//;

Cast:
	'(' Type ')'
;

PrefixOp:
	'+' | '-' | '~' | '!'
;

Primary:
	literal=Literal | 
	this='this'
	//|
//	expression=OrExpression
//	fieldAccess=FieldAccess |
//	classOrInterface=ClassOrInterfaceName |
//	'(' expression=Expression ')' 
//	| '(' subquery=Subquery ')' 
//	| methodInvocation=MethodInvocation 
//	| aggregateExpression=AggregateExpression
//	| variableName=VariableName
//	| parameterName=ParameterName
;

FieldAccess:
	fieldNames+=FieldName |
	primary=ID ('.' fieldNames+=FieldName)*
;

FieldName:
	ID
;

Type:
	PrimitiveType |
	ClassOrInterfaceName
;

PrimitiveType:
	NumericType |
	'boolean'
;

NumericType:
	IntegralType |
	FloatingPointType
;

IntegralType:
	'byte' | 'short' | 'int' | 'long' | 'char'
;

FloatingPointType:
	'float' | 'double'
;

IntegerLiteral:                                        
	INT
;

FloatingPointLiteral:
	INT		// TODO
;                                 

CharacterLiteral:                                      
	STRING		// TODO
;

StringLiteral:
	STRING
;                                         

BooleanLiteral:
    'true' | 'false'
;

NullLiteral:
    'null'
;

Literal:
    IntegerLiteral |
//    FloatingPointLiteral |
    BooleanLiteral |
//    CharacterLiteral |
    StringLiteral |
    NullLiteral
;